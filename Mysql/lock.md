mysql锁机制
===
目录
---

* [概述](#概述)  
* [级别](#级别)    
* [表级锁定（table-level）](#表级锁定（table-level）)  
* [行级锁定（row-level）](#行级锁定（row-level）)
* [页级锁定（page-level）](#页级锁定（page-level）)
* [参考](#参考)

概述
---
    数据库为了保证数据的一致性，共享资源在被并发访问的访问规则
    
级别
---
    mysql共有三种锁定机制: 表级锁定、行级锁定、页级锁定

表级锁定（table-level）
---
>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。

* MySQL表级锁的锁模式
    * MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。
    
    * MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）
    
* 加表锁
    * MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁

* 表锁优化
    * 查询表级锁争用情况 `show status like 'table%'` ，分析锁定资源争用原因
    
    * 缩短锁定时间
        1. 尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；
        2. 尽可能的建立足够高效的索引，让数据检索更迅速；
        3. 尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；
        4. 利用合适的机会优化MyISAM表数据文件。
        
    * 查询和插入锁争用
        >利用MyISAM的ConcurrentInsert（并发插入）特性
    
    * 合理利用读写优先级
        >通过执行命令`SET LOW_PRIORITY_UPDATES = 1`，使该连接读比写的优先级高。如果我们的系统是一个以读为主，可以设置此参数，如果以写为主，则不用设置
    
行级锁定（row-level）
---
>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。

* InnoDB锁定模式及实现机制

    * InnoDB的锁定模式可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX）
    
    * 意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁  
    >共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE  
    >排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
    
    * 事务不允许其他事务在记录上加冲突的锁，锁冲突如下：
    
    ![binding](./2.png)
    * InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索 数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
    * 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的
    * 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁
    * 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比 如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真 正使用了索引
    
* 间隙锁
    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件 的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓 的间隙锁（Next-Key锁）
    

页级锁定（page-level）
---
>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。使用页级锁定的主要是BerkeleyDB存储引擎。

参考
---
[MySQL－ InnoDB锁机制](https://www.cnblogs.com/aipiaoborensheng/p/5767459.html)